<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/"
  xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd"
  version="2.0"
  xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>南臣子</title>
    <link>2375.me</link>
    <description>RSS feed for 南臣子</description>
    <pubDate>Thu, 31 Oct 2013 21:50:16 +0800</pubDate>
    <item>
      <title>zookeeper client端实现解析</title>
      <link>2375.me/2013/10/31/Zookeeper-client%E7%AB%AF%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html</link>
      <description>&lt;p&gt;zookeeper 客户端的实现主要由以下三个类完成:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;org.apache.zookeeper.ZooKeeper&lt;/li&gt;

&lt;li&gt;org.apache.zookeeper.ClientCnxn&lt;/li&gt;

&lt;li&gt;org.apache.zookeeper.ClientCnxnSocketNIO&lt;/li&gt;
&lt;/ul&gt;</description>
      <pubDate>Thu, 31 Oct 2013 21:50:16 +0800</pubDate>
      <dc:date>2013-10-31T21:50:16+08:00</dc:date>
    </item>
    <item>
      <title>Java并发编程ConcurrentHashMap</title>
      <link>2375.me/2013/07/21/Java-ConcurrentHashMap.html</link>
      <description>&lt;p&gt;相对于线程不安全的HashMap来说,HashTable在存储table&lt;span /&gt;数组操作方法上的粗粒度synchronized则对性能损耗太多,先看看下面性能对比情况下(数值表示运行花费的毫秒数): <div class="highlight"><pre><code class="java"> <span class="n">Thread</span> <span class="n">number</span> <span class="n">HashTable</span> <span class="n">ConcurrentHashMap</span> <span class="mi">1</span> <span class="mi">19</span> <span class="mi">20</span> <span class="mi">2</span> <span class="mi">32</span> <span class="mi">27</span> <span class="mi">10</span> <span class="mi">131</span> <span class="mi">110</span> <span class="mi">40</span> <span class="mi">68</span> <span class="mi">264</span> <span class="mi">100</span> <span class="mi">124</span> <span class="mi">646</span> <span class="mi">200</span> <span class="mi">1318</span> <span class="mi">247</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">br</span> <span class="o">/&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="mi">500</span> <span class="mi">3244</span> <span class="mi">673</span> 
</code></pre></div> 测试代码的逻辑是一个map实例,每个并发的线程进行10,000次的随机put或者get的时间消耗&lt;/p&gt;</description>
      <pubDate>Sun, 21 Jul 2013 22:43:50 +0800</pubDate>
      <dc:date>2013-07-21T22:43:50+08:00</dc:date>
    </item>
    <item>
      <title>Linux 性能监控实践[1]</title>
      <link>2375.me/2013/07/06/Linux-Performance-monitoring-practice.html</link>
      <description>&lt;p&gt;搞Hadoop仅依靠ganglia或其他监控管理工具是远远不够的,真正了解熟悉各种mstat,nload,top等才靠谱,所以写篇linux的性能监控方面的文章搞清各个监控命令的细枝末节&lt;/p&gt;</description>
      <pubDate>Sat, 06 Jul 2013 19:07:50 +0800</pubDate>
      <dc:date>2013-07-06T19:07:50+08:00</dc:date>
    </item>
    <dc:date>2013-10-31T21:50:16+08:00</dc:date>
  </channel>
</rss>