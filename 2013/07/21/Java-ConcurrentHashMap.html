<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>南臣子 Blogging Like a Hacker</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">南臣子</a></h1>
              <a class="extra" href="/">home</a>
            </div>

                <h2>南臣子 Blogging Like a Hacker</h2>
<p class="meta">21 Jul 2013</p>

<div class="post">
<p>相对于线程不安全的HashMap来说,HashTable在存储table<span />数组操作方法上的粗粒度synchronized则对性能损耗太多,先看看下面性能对比情况下(数值表示运行花费的毫秒数):</p>
<div class='highlight'><pre><code class='ruby'>     <span class='err'>线程数</span>           <span class='no'>HashTable</span>          <span class='no'>ConcurrentHashMap</span>
      
      <span class='mi'>1</span>                  <span class='mi'>19</span>                     <span class='mi'>20</span>
      <span class='mi'>2</span>                  <span class='mi'>32</span>                     <span class='mi'>27</span>
      <span class='mi'>10</span>                 <span class='mi'>131</span>                    <span class='mi'>110</span>
      <span class='mi'>40</span>                 <span class='mi'>68</span>                     <span class='mi'>264</span>
      <span class='mi'>100</span>                <span class='mi'>124</span>                    <span class='mi'>646</span>
      <span class='mi'>200</span>                <span class='mi'>1318</span>                   <span class='mi'>247</span>      
      <span class='mi'>500</span>                <span class='mi'>3244</span>                   <span class='mi'>673</span>
</code></pre></div>
<p>测试代码的逻辑是一个map实例,每个并发的线程进行10,000次的随机put或者get的时间消耗</p>

<p><code>HashTable</code>通过synchronized实现table<span />的线程安全,方法上粗力度的加锁实现方式,限制了table<span />数组的操作上同个时间段都将被一个线程独占,其他并发的线程只能等待或轮循,所以HashTable的伸缩性较差,即使在系统的资源充足的情况下也无法通过更多的cpu线程占用率来提高Hashtable的性能,在读多写少的特定场景下性能更是较HashTable有更大的差距.HashTable在Iterator并不保证table中数据的一致性,迭代的过程中并未锁住table<span />,采用了fast fail的方式验证mod的值是否和expectedModCount值相等,若不等抛出ConcurrentModificationException,在并发的环境下同时进行迭代和put或delete很容易抛出该异常</p>

<p><code>ConcourrentHashMap</code>在锁的设计上进行了优化,设计了多组的分段锁,不同于HashTable的独占锁,ConcurrentHashMap采用了Segment数组的数据结构,每个Segment对应一个分段锁,其实在设计上每个Segment都相当于一个HashTable,简单的说就是一个ConcurrentHashMap的存储对应多个Segment数组(类似HashTable),每次必要的锁操作只对应到单个Segment,并不会锁住这个ConcurrentHashMap实例</p>
<div class='highlight'><pre><code class='ruby'>  
 <span class='no'>ConcurrentHashMap</span><span class='p'>()</span> <span class='p'>{</span>        <span class='sr'>//</span><span class='err'>默认的构造方法</span>
        <span class='n'>this</span><span class='p'>(</span><span class='mi'>16</span><span class='p'>,</span> <span class='mi'>0</span><span class='o'>.</span><span class='mi'>75</span><span class='n'>f</span><span class='p'>,</span> <span class='mi'>16</span><span class='p'>);</span>
    <span class='p'>}</span>

 <span class='kp'>public</span> <span class='no'>ConcurrentHashMap</span><span class='p'>(</span><span class='n'>int</span> <span class='n'>initialCapacity</span><span class='p'>,</span>
                             <span class='n'>float</span> <span class='n'>loadFactor</span><span class='p'>,</span> <span class='n'>int</span> <span class='n'>concurrencyLevel</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='k'>if</span> <span class='p'>(</span><span class='o'>!</span><span class='p'>(</span><span class='n'>loadFactor</span> <span class='o'>&gt;</span> <span class='mi'>0</span><span class='p'>)</span> <span class='o'>||</span> <span class='n'>initialCapacity</span> <span class='o'>&lt;</span> <span class='mi'>0</span> <span class='o'>||</span> <span class='n'>concurrencyLevel</span> <span class='o'>&lt;=</span> <span class='mi'>0</span><span class='p'>)</span>
            <span class='kp'>throw</span> <span class='kp'>new</span> <span class='no'>IllegalArgumentException</span><span class='p'>();</span>

        <span class='k'>if</span> <span class='p'>(</span><span class='n'>concurrencyLevel</span> <span class='o'>&gt;</span> <span class='no'>MAX_SEGMENTS</span><span class='p'>)</span>
            <span class='n'>concurrencyLevel</span> <span class='o'>=</span> <span class='no'>MAX_SEGMENTS</span><span class='p'>;</span>   
            <span class='sr'>//</span><span class='no'>MAX_SEGMENTS</span> <span class='o'>=</span> <span class='mi'>1</span> <span class='o'>&lt;&lt;</span> <span class='mi'>16</span>  <span class='err'>所以</span><span class='n'>concurrencyLevel</span><span class='err'>的值最大为</span><span class='mi'>65535</span>

        <span class='o'>//</span> <span class='no'>Find</span> <span class='n'>power</span><span class='o'>-</span><span class='n'>of</span><span class='o'>-</span><span class='n'>two</span> <span class='n'>sizes</span> <span class='n'>best</span> <span class='n'>matching</span> <span class='n'>arguments</span>
        <span class='n'>int</span> <span class='n'>sshift</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span>
        <span class='n'>int</span> <span class='n'>ssize</span> <span class='o'>=</span> <span class='mi'>1</span><span class='p'>;</span>
        <span class='k'>while</span> <span class='p'>(</span><span class='n'>ssize</span> <span class='o'>&lt;</span> <span class='n'>concurrencyLevel</span><span class='p'>)</span> <span class='p'>{</span>
            <span class='o'>++</span><span class='n'>sshift</span><span class='p'>;</span>       <span class='sr'>//</span><span class='err'>偏移量</span>
            <span class='n'>ssize</span> <span class='o'>&lt;&lt;=</span> <span class='mi'>1</span><span class='p'>;</span>   
            <span class='sr'>//ssi</span><span class='n'>ze</span><span class='err'>恰好大于</span><span class='n'>concurrencyLevel</span><span class='p'>,</span><span class='err'>且为</span><span class='mi'>2</span><span class='err'>的整数倍</span><span class='p'>,</span><span class='err'>即</span><span class='no'>Segment</span><span class='err'>的数组大小</span>
        <span class='p'>}</span>
        <span class='n'>segmentShift</span> <span class='o'>=</span> <span class='mi'>32</span> <span class='o'>-</span> <span class='n'>sshift</span><span class='p'>;</span><span class='o'>//</span><span class='mi'>32</span><span class='err'>与</span><span class='n'>sshift</span><span class='err'>的差值</span><span class='p'>,</span><span class='err'>用于</span><span class='n'>segment</span><span class='err'>的定位</span><span class='p'>,</span><span class='err'>下文会提到</span>
        <span class='n'>segmentMask</span> <span class='o'>=</span> <span class='n'>ssize</span> <span class='o'>-</span> <span class='mi'>1</span><span class='p'>;</span><span class='o'>//</span><span class='err'>比</span><span class='no'>Segment</span><span class='err'>数组长度小</span><span class='mi'>1</span><span class='err'>的掩码</span><span class='p'>,</span><span class='err'>应该用于求余</span>
        <span class='n'>this</span><span class='o'>.</span><span class='n'>segments</span> <span class='o'>=</span> <span class='no'>Segment</span><span class='o'>.</span><span class='n'>newArray</span><span class='p'>(</span><span class='n'>ssize</span><span class='p'>);</span><span class='o'>//</span><span class='err'>创建</span><span class='n'>ssize</span><span class='err'>大小的数组</span>

        <span class='k'>if</span> <span class='p'>(</span><span class='n'>initialCapacity</span> <span class='o'>&gt;</span> <span class='no'>MAXIMUM_CAPACITY</span><span class='p'>)</span>
            <span class='n'>initialCapacity</span> <span class='o'>=</span> <span class='no'>MAXIMUM_CAPACITY</span><span class='p'>;</span>
       <span class='sr'>//</span><span class='no'>ConcurrentHashMap</span><span class='err'>的每个</span><span class='no'>Segment</span><span class='err'>能够存储的最大值</span>  <span class='no'>MAXIMUM_CAPACITY</span> <span class='o'>=</span> <span class='mi'>1</span> <span class='o'>&lt;&lt;</span> <span class='mi'>30</span><span class='p'>;</span> 
        <span class='n'>int</span> <span class='n'>c</span> <span class='o'>=</span> <span class='n'>initialCapacity</span> <span class='o'>/</span> <span class='n'>ssize</span><span class='p'>;</span>           
        <span class='k'>if</span> <span class='p'>(</span><span class='n'>c</span> <span class='o'>*</span> <span class='n'>ssize</span> <span class='o'>&lt;</span> <span class='n'>initialCapacity</span><span class='p'>)</span>
            <span class='o'>++</span><span class='n'>c</span><span class='p'>;</span><span class='o'>//</span><span class='err'>调整</span><span class='n'>c</span><span class='err'>的值恰好为</span><span class='n'>ssize</span><span class='o'>*</span><span class='n'>C</span> <span class='o'>&gt;</span><span class='n'>initialCapacity</span><span class='err'>的条件下的最小值</span>
        <span class='n'>int</span> <span class='n'>cap</span> <span class='o'>=</span> <span class='mi'>1</span><span class='p'>;</span>
        <span class='k'>while</span> <span class='p'>(</span><span class='n'>cap</span> <span class='o'>&lt;</span> <span class='n'>c</span><span class='p'>)</span>
            <span class='n'>cap</span> <span class='o'>&lt;&lt;=</span> <span class='mi'>1</span><span class='p'>;</span> <span class='sr'>//</span><span class='n'>cap</span><span class='err'>为略大于</span><span class='n'>c</span><span class='err'>的</span><span class='mi'>2</span><span class='err'>的倍数</span>

        <span class='k'>for</span> <span class='p'>(</span><span class='n'>int</span> <span class='n'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span> <span class='n'>i</span> <span class='o'>&lt;</span> <span class='n'>this</span><span class='o'>.</span><span class='n'>segments</span><span class='o'>.</span><span class='n'>length</span><span class='p'>;</span> <span class='o'>++</span><span class='n'>i</span><span class='p'>)</span>
            <span class='n'>this</span><span class='o'>.</span><span class='n'>segments</span><span class='o'>[</span><span class='n'>i</span><span class='o'>]</span> <span class='o'>=</span> <span class='kp'>new</span> <span class='no'>Segment</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span><span class='p'>(</span><span class='n'>cap</span><span class='p'>,</span> <span class='n'>loadFactor</span><span class='p'>);</span>
            <span class='sr'>//</span><span class='err'>初始化</span><span class='no'>Segment</span><span class='err'>数组</span><span class='p'>,</span><span class='err'>初始大小为</span><span class='n'>cap</span>
    <span class='p'>}</span>


    <span class='n'>static</span> <span class='n'>final</span> <span class='k'>class</span> <span class='nc'>Segment</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>extends</span> <span class='no'>ReentrantLock</span> <span class='n'>implements</span> <span class='no'>Serializable</span> <span class='p'>{</span>


        <span class='n'>transient</span> <span class='n'>volatile</span> <span class='n'>int</span> <span class='n'>count</span><span class='p'>;</span>

        <span class='n'>transient</span> <span class='n'>int</span> <span class='n'>modCount</span><span class='p'>;</span>

        <span class='n'>transient</span> <span class='n'>int</span> <span class='n'>threshold</span><span class='p'>;</span>

        <span class='n'>transient</span> <span class='n'>volatile</span> <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;[]</span> <span class='n'>table</span><span class='p'>;</span>
        <span class='sr'>//</span><span class='err'>和</span><span class='n'>hashtable</span><span class='err'>结构类似</span><span class='p'>,</span><span class='err'>存放</span><span class='no'>Entry</span><span class='err'>的</span><span class='n'>table</span>

        <span class='n'>final</span> <span class='n'>float</span> <span class='n'>loadFactor</span><span class='p'>;</span>

        <span class='o'>.</span><span class='n'>.</span><span class='o'>.</span><span class='n'>.</span><span class='o'>.</span>
  <span class='p'>}</span>
</code></pre></div>
<p>ConcurrentHashMap初始化即通过一系列参数调整设置Segment的大小,ConcurrentHashMap维护了power of 2的Segment的数组.</p>
<div class='highlight'><pre><code class='ruby'>   
   <span class='kp'>public</span> <span class='n'>V</span> <span class='n'>put</span><span class='p'>(</span><span class='n'>K</span> <span class='n'>key</span><span class='p'>,</span> <span class='n'>V</span> <span class='n'>value</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='k'>if</span> <span class='p'>(</span><span class='n'>value</span> <span class='o'>==</span> <span class='n'>null</span><span class='p'>)</span>
            <span class='kp'>throw</span> <span class='kp'>new</span> <span class='no'>NullPointerException</span><span class='p'>();</span>
        <span class='n'>int</span> <span class='nb'>hash</span> <span class='o'>=</span> <span class='nb'>hash</span><span class='p'>(</span><span class='n'>key</span><span class='o'>.</span><span class='n'>hashCode</span><span class='p'>());</span>   <span class='sr'>//</span><span class='err'>第一次</span><span class='nb'>hash</span>
        <span class='k'>return</span> <span class='n'>segmentFor</span><span class='p'>(</span><span class='nb'>hash</span><span class='p'>)</span><span class='o'>.</span><span class='n'>put</span><span class='p'>(</span><span class='n'>key</span><span class='p'>,</span> <span class='nb'>hash</span><span class='p'>,</span> <span class='n'>value</span><span class='p'>,</span> <span class='kp'>false</span><span class='p'>);</span>
    <span class='p'>}</span>
   
   <span class='n'>final</span> <span class='no'>Segment</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>segmentFor</span><span class='p'>(</span><span class='n'>int</span> <span class='nb'>hash</span><span class='p'>)</span> <span class='p'>{</span>
        <span class='k'>return</span> <span class='n'>segments</span><span class='o'>[</span><span class='p'>(</span><span class='nb'>hash</span> <span class='o'>&gt;&gt;&gt;</span> <span class='n'>segmentShift</span><span class='p'>)</span> <span class='o'>&amp;</span> <span class='n'>segmentMask</span><span class='o'>]</span><span class='p'>;</span>
    <span class='p'>}</span>
   	
   <span class='kp'>private</span> <span class='n'>static</span> <span class='n'>int</span> <span class='nb'>hash</span><span class='p'>(</span><span class='n'>int</span> <span class='n'>h</span><span class='p'>)</span> <span class='p'>{</span> 
        <span class='n'>h</span> <span class='o'>+=</span> <span class='p'>(</span><span class='n'>h</span> <span class='o'>&lt;&lt;</span>  <span class='mi'>15</span><span class='p'>)</span> <span class='o'>^</span> <span class='mh'>0xffffcd7d</span><span class='p'>;</span>
        <span class='n'>h</span> <span class='o'>^=</span> <span class='p'>(</span><span class='n'>h</span> <span class='o'>&gt;&gt;&gt;</span> <span class='mi'>10</span><span class='p'>);</span>
        <span class='n'>h</span> <span class='o'>+=</span> <span class='p'>(</span><span class='n'>h</span> <span class='o'>&lt;&lt;</span>   <span class='mi'>3</span><span class='p'>);</span>
        <span class='n'>h</span> <span class='o'>^=</span> <span class='p'>(</span><span class='n'>h</span> <span class='o'>&gt;&gt;&gt;</span>  <span class='mi'>6</span><span class='p'>);</span>
        <span class='n'>h</span> <span class='o'>+=</span> <span class='p'>(</span><span class='n'>h</span> <span class='o'>&lt;&lt;</span>   <span class='mi'>2</span><span class='p'>)</span> <span class='o'>+</span> <span class='p'>(</span><span class='n'>h</span> <span class='o'>&lt;&lt;</span> <span class='mi'>14</span><span class='p'>);</span>
        <span class='k'>return</span> <span class='n'>h</span> <span class='o'>^</span> <span class='p'>(</span><span class='n'>h</span> <span class='o'>&gt;&gt;&gt;</span> <span class='mi'>16</span><span class='p'>);</span>
    <span class='p'>}</span>
</code></pre></div>
<p>ConcurrentHashMap的put操作,其中hash()函数的作用是根据不同的key计算散列码(数学问题)目的是使数据通过hash值&amp;mask数组大小达到数据均匀分配到Entry数组上的目的,segments()通过hash的值定位数据到一个确定的Segment上,通过Segments可以确定ConcurrentHashMap的Segments数组大小在实例初始化后就已经确定的不允许扩充的,所以segment数组,segmentMask和segmentShift属性都是final的.</p>
<div class='highlight'><pre><code class='ruby'> <span class='n'>V</span> <span class='n'>put</span><span class='p'>(</span><span class='n'>K</span> <span class='n'>key</span><span class='p'>,</span> <span class='n'>int</span> <span class='nb'>hash</span><span class='p'>,</span> <span class='n'>V</span> <span class='n'>value</span><span class='p'>,</span> <span class='n'>boolean</span> <span class='n'>onlyIfAbsent</span><span class='p'>)</span> <span class='p'>{</span>
            <span class='n'>lock</span><span class='p'>();</span>  <span class='sr'>//</span><span class='err'>获得当前</span><span class='no'>Segment</span><span class='err'>的锁对象</span>
            <span class='n'>try</span> <span class='p'>{</span>
                <span class='n'>int</span> <span class='n'>c</span> <span class='o'>=</span> <span class='n'>count</span><span class='p'>;</span>
                <span class='k'>if</span> <span class='p'>(</span><span class='n'>c</span><span class='o'>++</span> <span class='o'>&gt;</span> <span class='n'>threshold</span><span class='p'>)</span> <span class='sr'>//</span> <span class='k'>ensure</span> <span class='n'>capacity</span>
                    <span class='n'>rehash</span><span class='p'>();</span>  <span class='sr'>//</span><span class='err'>大小大于当前阀值</span><span class='p'>,</span><span class='err'>扩充</span><span class='no'>Entry</span><span class='o'>[]</span><span class='err'>数组的大小</span>
                <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;[]</span> <span class='n'>tab</span> <span class='o'>=</span> <span class='n'>table</span><span class='p'>;</span>
                <span class='n'>int</span> <span class='n'>index</span> <span class='o'>=</span> <span class='nb'>hash</span> <span class='o'>&amp;</span> <span class='p'>(</span><span class='n'>tab</span><span class='o'>.</span><span class='n'>length</span> <span class='o'>-</span> <span class='mi'>1</span><span class='p'>);</span>  <span class='sr'>//</span><span class='nb'>hash</span><span class='err'>值定位到一个</span><span class='n'>slot</span>
                <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>first</span> <span class='o'>=</span> <span class='n'>tab</span><span class='o'>[</span><span class='n'>index</span><span class='o'>]</span><span class='p'>;</span>
                <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>e</span> <span class='o'>=</span> <span class='n'>first</span><span class='p'>;</span>
                <span class='k'>while</span> <span class='p'>(</span><span class='n'>e</span> <span class='o'>!=</span> <span class='n'>null</span> <span class='o'>&amp;&amp;</span> <span class='p'>(</span><span class='n'>e</span><span class='o'>.</span><span class='n'>hash</span> <span class='o'>!=</span> <span class='nb'>hash</span> <span class='o'>||</span> <span class='o'>!</span><span class='n'>key</span><span class='o'>.</span><span class='n'>equals</span><span class='p'>(</span><span class='n'>e</span><span class='o'>.</span><span class='n'>key</span><span class='p'>)))</span>
                    <span class='n'>e</span> <span class='o'>=</span> <span class='n'>e</span><span class='o'>.</span><span class='n'>next</span><span class='p'>;</span> <span class='sr'>//</span><span class='err'>查找当前</span><span class='n'>slot</span><span class='err'>的链表中是否存在当前插入</span><span class='n'>key</span>

                <span class='n'>V</span> <span class='n'>oldValue</span><span class='p'>;</span>
                <span class='k'>if</span> <span class='p'>(</span><span class='n'>e</span> <span class='o'>!=</span> <span class='n'>null</span><span class='p'>)</span> <span class='p'>{</span>    <span class='sr'>//</span><span class='err'>存在的条件下</span>
                    <span class='n'>oldValue</span> <span class='o'>=</span> <span class='n'>e</span><span class='o'>.</span><span class='n'>value</span><span class='p'>;</span> 
                    <span class='k'>if</span> <span class='p'>(</span><span class='o'>!</span><span class='n'>onlyIfAbsent</span><span class='p'>)</span>    
                        <span class='n'>e</span><span class='o'>.</span><span class='n'>value</span> <span class='o'>=</span> <span class='n'>value</span><span class='p'>;</span> <span class='sr'>//</span><span class='err'>在</span><span class='n'>onlyIfAbsent</span><span class='err'>为</span><span class='kp'>true</span><span class='p'>,</span><span class='err'>即不存在</span><span class='n'>key</span><span class='err'>的情况下才插入</span>
                <span class='p'>}</span>
                <span class='k'>else</span> <span class='p'>{</span>
                    <span class='n'>oldValue</span> <span class='o'>=</span> <span class='n'>null</span><span class='p'>;</span>   <span class='sr'>//</span><span class='err'>不存在的条件下</span>
                    <span class='o'>++</span><span class='n'>modCount</span><span class='p'>;</span>
                    <span class='n'>tab</span><span class='o'>[</span><span class='n'>index</span><span class='o'>]</span> <span class='o'>=</span> <span class='kp'>new</span> <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span><span class='p'>(</span><span class='n'>key</span><span class='p'>,</span> <span class='nb'>hash</span><span class='p'>,</span> <span class='n'>first</span><span class='p'>,</span> <span class='n'>value</span><span class='p'>);</span>  
                    <span class='sr'>//</span><span class='err'>采用头插法插入新</span><span class='n'>key</span>
                    <span class='n'>count</span> <span class='o'>=</span> <span class='n'>c</span><span class='p'>;</span> <span class='sr'>//</span> <span class='n'>write</span><span class='o'>-</span><span class='n'>volatile</span>
                <span class='p'>}</span>
                <span class='k'>return</span> <span class='n'>oldValue</span><span class='p'>;</span>
            <span class='p'>}</span> <span class='n'>finally</span> <span class='p'>{</span>
                <span class='n'>unlock</span><span class='p'>();</span> <span class='sr'>//</span><span class='err'>释放当前锁对象</span>
            <span class='p'>}</span>
        <span class='p'>}</span>
</code></pre></div>
<p>Segment插入类似于HashTable的put获得锁的情况下进行操作,最大的不同是HashTable要获得当前实例的全局锁,阻塞其他线程对实例的syn操作,而ConcuurentHashMap采用了分段的锁机制,当前获得的锁只是阻塞了其对应的Segment,而相对其他的ssize-1的Segments并无影响,分段锁达到了细粒化锁的目的.多消耗的仅是segment()定位segment的操作</p>
<div class='highlight'><pre><code class='ruby'>     <span class='n'>static</span> <span class='n'>final</span> <span class='k'>class</span> <span class='nc'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='p'>{</span> <span class='sr'>//</span><span class='no'>Entry</span><span class='err'>的实现类</span>
        <span class='sr'>//</span><span class='err'>一个</span><span class='no'>Entry</span><span class='err'>的实例变量的</span><span class='n'>key</span><span class='err'>是永久不变的</span><span class='p'>,</span><span class='err'>推之</span><span class='nb'>hash</span><span class='err'>也是</span><span class='n'>final</span>
        <span class='n'>final</span> <span class='n'>K</span> <span class='n'>key</span><span class='p'>;</span>
        <span class='n'>final</span> <span class='n'>int</span> <span class='nb'>hash</span><span class='p'>;</span>
        <span class='sr'>//</span><span class='err'>对于多线程的更改操作即保证值更改的立即可见性</span>
        <span class='n'>volatile</span> <span class='n'>V</span> <span class='n'>value</span><span class='p'>;</span>
        <span class='sr'>//</span><span class='err'>修饰符为</span><span class='n'>final</span><span class='err'>决定了</span><span class='k'>next</span><span class='err'>的不变性</span><span class='p'>,</span><span class='err'>所以链表中的删除和</span><span class='n'>rehash</span><span class='err'>的过程都要重新</span><span class='n'>build</span><span class='err'>之前的所有</span><span class='n'>e</span><span class='err'>节点</span><span class='p'>,</span>
        <span class='n'>final</span> <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='k'>next</span><span class='p'>;</span>
                                          
        <span class='no'>HashEntry</span><span class='p'>(</span><span class='n'>K</span> <span class='n'>key</span><span class='p'>,</span> <span class='n'>int</span> <span class='nb'>hash</span><span class='p'>,</span> <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='k'>next</span><span class='p'>,</span> <span class='n'>V</span> <span class='n'>value</span><span class='p'>)</span> <span class='p'>{</span>
            <span class='n'>this</span><span class='o'>.</span><span class='n'>key</span> <span class='o'>=</span> <span class='n'>key</span><span class='p'>;</span>
            <span class='n'>this</span><span class='o'>.</span><span class='n'>hash</span> <span class='o'>=</span> <span class='nb'>hash</span><span class='p'>;</span>
            <span class='n'>this</span><span class='o'>.</span><span class='n'>next</span> <span class='o'>=</span> <span class='k'>next</span><span class='p'>;</span>
            <span class='n'>this</span><span class='o'>.</span><span class='n'>value</span> <span class='o'>=</span> <span class='n'>value</span><span class='p'>;</span>
        <span class='p'>}</span>

	<span class='vi'>@SuppressWarnings</span><span class='p'>(</span><span class='s2'>&quot;unchecked&quot;</span><span class='p'>)</span>
	<span class='n'>static</span> <span class='n'>final</span> <span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;[]</span> <span class='n'>newArray</span><span class='p'>(</span><span class='n'>int</span> <span class='n'>i</span><span class='p'>)</span> <span class='p'>{</span>
	    <span class='k'>return</span> <span class='kp'>new</span> <span class='no'>HashEntry</span><span class='o'>[</span><span class='n'>i</span><span class='o'>]</span><span class='p'>;</span>
	<span class='p'>}</span>
    <span class='p'>}</span>

     <span class='n'>void</span> <span class='n'>rehash</span><span class='p'>()</span> <span class='p'>{</span>   
            <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;[]</span> <span class='n'>oldTable</span> <span class='o'>=</span> <span class='n'>table</span><span class='p'>;</span>
            <span class='n'>int</span> <span class='n'>oldCapacity</span> <span class='o'>=</span> <span class='n'>oldTable</span><span class='o'>.</span><span class='n'>length</span><span class='p'>;</span>
            <span class='k'>if</span> <span class='p'>(</span><span class='n'>oldCapacity</span> <span class='o'>&gt;=</span> <span class='no'>MAXIMUM_CAPACITY</span><span class='p'>)</span>   <span class='sr'>//</span><span class='err'>每个</span><span class='no'>Segment</span><span class='err'>的最大值为</span> <span class='mi'>1</span> <span class='o'>&gt;&gt;</span> <span class='mi'>32</span>
                <span class='k'>return</span><span class='p'>;</span>

           <span class='sr'>//</span><span class='err'>新开辟</span><span class='mi'>2</span><span class='err'>倍的</span><span class='n'>oldCapacity</span>
            <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;[]</span> <span class='n'>newTable</span> <span class='o'>=</span> <span class='no'>HashEntry</span><span class='o'>.</span><span class='n'>newArray</span><span class='p'>(</span><span class='n'>oldCapacity</span><span class='o'>&lt;&lt;</span><span class='mi'>1</span><span class='p'>);</span>
            <span class='n'>threshold</span> <span class='o'>=</span> <span class='p'>(</span><span class='n'>int</span><span class='p'>)(</span><span class='n'>newTable</span><span class='o'>.</span><span class='n'>length</span> <span class='o'>*</span> <span class='n'>loadFactor</span><span class='p'>);</span>
            <span class='n'>int</span> <span class='n'>sizeMask</span> <span class='o'>=</span> <span class='n'>newTable</span><span class='o'>.</span><span class='n'>length</span> <span class='o'>-</span> <span class='mi'>1</span><span class='p'>;</span>    <span class='sr'>//</span><span class='err'>新数组长度的掩码</span>
            <span class='k'>for</span> <span class='p'>(</span><span class='n'>int</span> <span class='n'>i</span> <span class='o'>=</span> <span class='mi'>0</span><span class='p'>;</span> <span class='n'>i</span> <span class='o'>&lt;</span> <span class='n'>oldCapacity</span> <span class='p'>;</span> <span class='n'>i</span><span class='o'>++</span><span class='p'>)</span> <span class='p'>{</span>
                <span class='sr'>//</span> <span class='no'>We</span> <span class='n'>need</span> <span class='n'>to</span> <span class='n'>guarantee</span> <span class='n'>that</span> <span class='n'>any</span> <span class='n'>existing</span> <span class='n'>reads</span> <span class='n'>of</span> <span class='n'>old</span> <span class='no'>Map</span> <span class='n'>can</span>
                <span class='sr'>//</span>  <span class='n'>proceed</span><span class='o'>.</span> <span class='no'>So</span> <span class='n'>we</span> <span class='n'>cannot</span> <span class='n'>yet</span> <span class='n'>null</span> <span class='n'>out</span> <span class='n'>each</span> <span class='n'>bin</span><span class='o'>.</span>
                <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>e</span> <span class='o'>=</span> <span class='n'>oldTable</span><span class='o'>[</span><span class='n'>i</span><span class='o'>]</span><span class='p'>;</span>

                <span class='k'>if</span> <span class='p'>(</span><span class='n'>e</span> <span class='o'>!=</span> <span class='n'>null</span><span class='p'>)</span> <span class='p'>{</span>
                    <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='k'>next</span> <span class='o'>=</span> <span class='n'>e</span><span class='o'>.</span><span class='n'>next</span><span class='p'>;</span>
                    <span class='n'>int</span> <span class='n'>idx</span> <span class='o'>=</span> <span class='n'>e</span><span class='o'>.</span><span class='n'>hash</span> <span class='o'>&amp;</span> <span class='n'>sizeMask</span><span class='p'>;</span>

                    <span class='sr'>//</span>  <span class='no'>Single</span> <span class='n'>node</span> <span class='n'>on</span> <span class='n'>list</span>
                    <span class='k'>if</span> <span class='p'>(</span><span class='k'>next</span> <span class='o'>==</span> <span class='n'>null</span><span class='p'>)</span>
                        <span class='n'>newTable</span><span class='o'>[</span><span class='n'>idx</span><span class='o'>]</span> <span class='o'>=</span> <span class='n'>e</span><span class='p'>;</span>  
       <span class='sr'>//nex</span><span class='n'>t</span><span class='err'>节点为</span><span class='n'>null</span><span class='err'>保证了</span><span class='nb'>hash</span><span class='err'>值到这个槽位的值仅此一家</span><span class='p'>,</span><span class='err'>别无分店</span><span class='p'>,</span><span class='err'>所有直接对应到</span><span class='n'>newTable</span><span class='err'>数组的</span><span class='n'>idx</span><span class='err'>的</span>
      <span class='sr'>//</span><span class='err'>槽位上</span><span class='p'>,</span><span class='err'>细想想</span><span class='p'>,</span><span class='err'>每个</span><span class='n'>key</span><span class='err'>的</span><span class='nb'>hash</span><span class='err'>值是和掩码即数组长度在只有一家的情况下在扩容后同样也不会出现第二个</span>                                           
                        <span class='sr'>//</span><span class='err'>和它冲突的</span><span class='n'>key</span>
                    <span class='k'>else</span> <span class='p'>{</span>
                        <span class='sr'>//</span> <span class='no'>Reuse</span> <span class='n'>trailing</span> <span class='n'>consecutive</span> <span class='n'>sequence</span> <span class='n'>at</span> <span class='n'>same</span> <span class='n'>slot</span>
                        <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>lastRun</span> <span class='o'>=</span> <span class='n'>e</span><span class='p'>;</span>      
                        <span class='n'>int</span> <span class='n'>lastIdx</span> <span class='o'>=</span> <span class='n'>idx</span><span class='p'>;</span>
                         <span class='sr'>//</span><span class='n'>rehash</span><span class='err'>的算法有点小技巧</span>
                        <span class='k'>for</span> <span class='p'>(</span><span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>last</span> <span class='o'>=</span> <span class='k'>next</span><span class='p'>;</span>        
                             <span class='n'>last</span> <span class='o'>!=</span> <span class='n'>null</span><span class='p'>;</span>
                             <span class='n'>last</span> <span class='o'>=</span> <span class='n'>last</span><span class='o'>.</span><span class='n'>next</span><span class='p'>)</span> <span class='p'>{</span>
                            <span class='n'>int</span> <span class='n'>k</span> <span class='o'>=</span> <span class='n'>last</span><span class='o'>.</span><span class='n'>hash</span> <span class='o'>&amp;</span> <span class='n'>sizeMask</span><span class='p'>;</span>
                            <span class='k'>if</span> <span class='p'>(</span><span class='n'>k</span> <span class='o'>!=</span> <span class='n'>lastIdx</span><span class='p'>)</span> <span class='p'>{</span>
                                <span class='n'>lastIdx</span> <span class='o'>=</span> <span class='n'>k</span><span class='p'>;</span><span class='o'>//</span><span class='err'>算出</span><span class='n'>old</span><span class='err'>链表下最后一个</span><span class='n'>key</span><span class='err'>在新</span><span class='n'>sizemask</span><span class='err'>下不同的</span><span class='no'>Idx</span><span class='err'>值</span>
                                <span class='n'>lastRun</span> <span class='o'>=</span> <span class='n'>last</span><span class='p'>;</span>
                            <span class='p'>}</span>
                        <span class='p'>}</span>
                        <span class='n'>newTable</span><span class='o'>[</span><span class='n'>lastIdx</span><span class='o'>]</span> <span class='o'>=</span> <span class='n'>lastRun</span><span class='p'>;</span>

                        <span class='sr'>//</span> <span class='no'>Clone</span> <span class='n'>all</span> <span class='n'>remaining</span> <span class='n'>nodes</span>
                        <span class='k'>for</span> <span class='p'>(</span><span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='nb'>p</span> <span class='o'>=</span> <span class='n'>e</span><span class='p'>;</span> <span class='nb'>p</span> <span class='o'>!=</span> <span class='n'>lastRun</span><span class='p'>;</span> <span class='nb'>p</span> <span class='o'>=</span> <span class='nb'>p</span><span class='o'>.</span><span class='n'>next</span><span class='p'>)</span> <span class='p'>{</span>   
                           <span class='sr'>//</span><span class='err'>只用重新</span><span class='kp'>new</span> <span class='n'>lastRun</span><span class='err'>之前的节点</span><span class='p'>,</span><span class='err'>而在</span><span class='n'>lastrun</span><span class='err'>之后的节点因为会</span>                                                                        
                           <span class='sr'>//</span><span class='err'>定位到同一个</span><span class='no'>Idx</span><span class='err'>上所以直接由</span><span class='n'>lastRun</span><span class='err'>带过去就可以了</span>
                            <span class='n'>int</span> <span class='n'>k</span> <span class='o'>=</span> <span class='nb'>p</span><span class='o'>.</span><span class='n'>hash</span> <span class='o'>&amp;</span> <span class='n'>sizeMask</span><span class='p'>;</span>
                            <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>n</span> <span class='o'>=</span> <span class='n'>newTable</span><span class='o'>[</span><span class='n'>k</span><span class='o'>]</span><span class='p'>;</span>   <span class='sr'>//</span><span class='err'>采用头插入法</span>
                            <span class='n'>newTable</span><span class='o'>[</span><span class='n'>k</span><span class='o'>]</span> <span class='o'>=</span> <span class='kp'>new</span> <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span><span class='p'>(</span><span class='nb'>p</span><span class='o'>.</span><span class='n'>key</span><span class='p'>,</span> <span class='nb'>p</span><span class='o'>.</span><span class='n'>hash</span><span class='p'>,</span>
                                                             <span class='n'>n</span><span class='p'>,</span> <span class='nb'>p</span><span class='o'>.</span><span class='n'>value</span><span class='p'>);</span>
                        <span class='p'>}</span>
                    <span class='p'>}</span>
                <span class='p'>}</span>
            <span class='p'>}</span>
            <span class='n'>table</span> <span class='o'>=</span> <span class='n'>newTable</span><span class='p'>;</span>
        <span class='p'>}</span>    
</code></pre></div>
<p>rehash是在拿到lock的情况下进行的,对于旧的oldTable不存在更改的情况,对于无锁的get的操作来说,只是happen before的关系,不影响读取,注意Concurrent不存在hashmap中并发rehash导致的死锁问题</p>
<div class='highlight'><pre><code class='ruby'> 	
    <span class='n'>V</span> <span class='n'>get</span><span class='p'>(</span><span class='no'>Oemove</span><span class='p'>;</span> <span class='n'>match</span> <span class='n'>on</span> <span class='n'>key</span> <span class='n'>only</span> <span class='k'>if</span> <span class='n'>value</span> <span class='n'>null</span><span class='p'>,</span> <span class='k'>else</span> <span class='n'>match</span> <span class='n'>both</span><span class='o'>.</span>
         <span class='o'>*/</span>
        <span class='n'>V</span> <span class='n'>remove</span><span class='p'>(</span><span class='no'>Object</span> <span class='n'>key</span><span class='p'>,</span> <span class='n'>int</span> <span class='nb'>hash</span><span class='p'>,</span> <span class='no'>Object</span> <span class='n'>value</span><span class='p'>)</span> <span class='p'>{</span>
            <span class='n'>lock</span><span class='p'>();</span>
            <span class='n'>try</span> <span class='p'>{</span>
                <span class='n'>int</span> <span class='n'>c</span> <span class='o'>=</span> <span class='n'>count</span> <span class='o'>-</span> <span class='mi'>1</span><span class='p'>;</span>
                <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;[]</span> <span class='n'>tab</span> <span class='o'>=</span> <span class='n'>table</span><span class='p'>;</span>
                <span class='n'>int</span> <span class='n'>index</span> <span class='o'>=</span> <span class='nb'>hash</span> <span class='o'>&amp;</span> <span class='p'>(</span><span class='n'>tab</span><span class='o'>.</span><span class='n'>length</span> <span class='o'>-</span> <span class='mi'>1</span><span class='p'>);</span>
                <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>first</span> <span class='o'>=</span> <span class='n'>tab</span><span class='o'>[</span><span class='n'>index</span><span class='o'>]</span><span class='p'>;</span>
                <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>e</span> <span class='o'>=</span> <span class='n'>first</span><span class='p'>;</span>
                <span class='k'>while</span> <span class='p'>(</span><span class='n'>e</span> <span class='o'>!=</span> <span class='n'>null</span> <span class='o'>&amp;&amp;</span> <span class='p'>(</span><span class='n'>e</span><span class='o'>.</span><span class='n'>hash</span> <span class='o'>!=</span> <span class='nb'>hash</span> <span class='o'>||</span> <span class='o'>!</span><span class='n'>key</span><span class='o'>.</span><span class='n'>equals</span><span class='p'>(</span><span class='n'>e</span><span class='o'>.</span><span class='n'>key</span><span class='p'>)))</span>
                    <span class='n'>e</span> <span class='o'>=</span> <span class='n'>e</span><span class='o'>.</span><span class='n'>next</span><span class='p'>;</span>

                <span class='n'>V</span> <span class='n'>oldValue</span> <span class='o'>=</span> <span class='n'>null</span><span class='p'>;</span>
                <span class='k'>if</span> <span class='p'>(</span><span class='n'>e</span> <span class='o'>!=</span> <span class='n'>null</span><span class='p'>)</span> <span class='p'>{</span>
                    <span class='n'>V</span> <span class='n'>v</span> <span class='o'>=</span> <span class='n'>e</span><span class='o'>.</span><span class='n'>value</span><span class='p'>;</span>
                    <span class='k'>if</span> <span class='p'>(</span><span class='n'>value</span> <span class='o'>==</span> <span class='n'>null</span> <span class='o'>||</span> <span class='n'>value</span><span class='o'>.</span><span class='n'>equals</span><span class='p'>(</span><span class='n'>v</span><span class='p'>))</span> <span class='p'>{</span>
                        <span class='n'>oldValue</span> <span class='o'>=</span> <span class='n'>v</span><span class='p'>;</span>
                        <span class='sr'>//</span> <span class='no'>All</span> <span class='n'>entries</span> <span class='n'>following</span> <span class='n'>removed</span> <span class='n'>node</span> <span class='n'>can</span> <span class='n'>stay</span>
                        <span class='sr'>//</span> <span class='k'>in</span> <span class='n'>list</span><span class='p'>,</span> <span class='n'>but</span> <span class='n'>all</span> <span class='n'>preceding</span> <span class='n'>ones</span> <span class='n'>need</span> <span class='n'>to</span> <span class='n'>be</span>
                        <span class='sr'>//</span> <span class='n'>cloned</span><span class='o'>.</span>
                        <span class='o'>++</span><span class='n'>modCount</span><span class='p'>;</span>
                        <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>newFirst</span> <span class='o'>=</span> <span class='n'>e</span><span class='o'>.</span><span class='n'>next</span><span class='p'>;</span>
                        <span class='k'>for</span> <span class='p'>(</span><span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='nb'>p</span> <span class='o'>=</span> <span class='n'>first</span><span class='p'>;</span> <span class='nb'>p</span> <span class='o'>!=</span> <span class='n'>e</span><span class='p'>;</span> <span class='nb'>p</span> <span class='o'>=</span> <span class='nb'>p</span><span class='o'>.</span><span class='n'>next</span><span class='p'>)</span>
                            <span class='n'>newFirst</span> <span class='o'>=</span> <span class='kp'>new</span> <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span><span class='p'>(</span><span class='nb'>p</span><span class='o'>.</span><span class='n'>key</span><span class='p'>,</span> <span class='nb'>p</span><span class='o'>.</span><span class='n'>hash</span><span class='p'>,</span>
                                                          <span class='n'>newFirst</span><span class='p'>,</span> <span class='nb'>p</span><span class='o'>.</span><span class='n'>value</span><span class='p'>);</span>
                        <span class='n'>tab</span><span class='o'>[</span><span class='n'>index</span><span class='o'>]</span> <span class='o'>=</span> <span class='n'>newFirst</span><span class='p'>;</span>
                        <span class='n'>count</span> <span class='o'>=</span> <span class='n'>c</span><span class='p'>;</span> <span class='sr'>//</span> <span class='n'>write</span><span class='o'>-</span><span class='n'>volatile</span>
                    <span class='p'>}</span>
                <span class='p'>}</span>
                <span class='k'>return</span> <span class='n'>oldValue</span><span class='p'>;</span>
            <span class='p'>}</span> <span class='n'>finally</span> <span class='p'>{</span>
                <span class='n'>unlock</span><span class='p'>();</span>
            <span class='p'>}</span>
        <span class='p'>}</span>
</code></pre></div>
<p>remove的操作其实和rehash有些相似的地方,对于next的修饰符是final,所以对于remove之前的所有节点都需要重新build.</p>
<div class='highlight'><pre><code class='ruby'>         <span class='n'>V</span> <span class='n'>get</span><span class='p'>(</span><span class='no'>Object</span> <span class='n'>key</span><span class='p'>,</span> <span class='n'>int</span> <span class='nb'>hash</span><span class='p'>)</span> <span class='p'>{</span>
            <span class='k'>if</span> <span class='p'>(</span><span class='n'>count</span> <span class='o'>!=</span> <span class='mi'>0</span><span class='p'>)</span> <span class='p'>{</span> <span class='sr'>//</span> <span class='n'>read</span><span class='o'>-</span><span class='n'>volatile</span>
                <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>e</span> <span class='o'>=</span> <span class='n'>getFirst</span><span class='p'>(</span><span class='nb'>hash</span><span class='p'>);</span>  <span class='sr'>//</span><span class='n'>getFirst</span><span class='err'>利用</span><span class='nb'>hash</span><span class='err'>值返回</span><span class='n'>key</span><span class='err'>所落在的槽位</span>
                <span class='k'>while</span> <span class='p'>(</span><span class='n'>e</span> <span class='o'>!=</span> <span class='n'>null</span><span class='p'>)</span> <span class='p'>{</span>
                    <span class='k'>if</span> <span class='p'>(</span><span class='n'>e</span><span class='o'>.</span><span class='n'>hash</span> <span class='o'>==</span> <span class='nb'>hash</span> <span class='o'>&amp;&amp;</span> <span class='n'>key</span><span class='o'>.</span><span class='n'>equals</span><span class='p'>(</span><span class='n'>e</span><span class='o'>.</span><span class='n'>key</span><span class='p'>))</span> <span class='p'>{</span>
                        <span class='n'>V</span> <span class='n'>v</span> <span class='o'>=</span> <span class='n'>e</span><span class='o'>.</span><span class='n'>value</span><span class='p'>;</span>
                        <span class='k'>if</span> <span class='p'>(</span><span class='n'>v</span> <span class='o'>!=</span> <span class='n'>null</span><span class='p'>)</span>
                            <span class='k'>return</span> <span class='n'>v</span><span class='p'>;</span>
                        <span class='k'>return</span> <span class='n'>readValueUnderLock</span><span class='p'>(</span><span class='n'>e</span><span class='p'>);</span> <span class='sr'>//</span> <span class='n'>recheck</span>
                    <span class='p'>}</span>
                    <span class='n'>e</span> <span class='o'>=</span> <span class='n'>e</span><span class='o'>.</span><span class='n'>next</span><span class='p'>;</span>
                <span class='p'>}</span>
            <span class='p'>}</span>
            <span class='k'>return</span> <span class='n'>null</span><span class='p'>;</span>
      <span class='p'>}</span>

    <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;</span> <span class='n'>getFirst</span><span class='p'>(</span><span class='n'>int</span> <span class='nb'>hash</span><span class='p'>)</span> <span class='p'>{</span>
            <span class='no'>HashEntry</span><span class='o'>&lt;</span><span class='n'>K</span><span class='p'>,</span><span class='n'>V</span><span class='o'>&gt;[]</span> <span class='n'>tab</span> <span class='o'>=</span> <span class='n'>table</span><span class='p'>;</span>
            <span class='k'>return</span> <span class='n'>tab</span><span class='o'>[</span><span class='nb'>hash</span> <span class='o'>&amp;</span> <span class='p'>(</span><span class='n'>tab</span><span class='o'>.</span><span class='n'>length</span> <span class='o'>-</span> <span class='mi'>1</span><span class='p'>)</span><span class='o'>]</span><span class='p'>;</span>
        <span class='p'>}</span>
</code></pre></div>
<p>get并不需要加锁,why?首先value的属性通过voliate修饰,轻量级的锁,若任何线程对v的修改,则get的操作会立即从main memory看到此改变.其次,<code>v != null</code>的判断,ConcurrentHashMap的put入口是不允许有null的value的值,那在segment的get内部实现中,为什么还要多此一举的判断?这是因为线程B进行put(key)的操作和线程A读取(key)的操作不存在happen before的关系,所以读到的可能为工作线程memory里的null值,当然这重情况出现的概率很小很小很小,所以防止出现这种情况,利用加锁强制刷新读取e的值.</p>

<p>ConcurrentHashMap不是绝对意义上的put和get等操作的线程安全,但它在并发的性能和数据缓存一致性方面是个很好的实现方式,数据绝对的一致性还是要用collections.synChronizedMap方法实现.它的实质是在hashMap上封装了一层synchronized的代理.效率和HashTable是差不多的.</p>

<p>相关文章</p>

<ul>
<li>
<p><a href='http://www.infoq.com/cn/articles/ConcurrentHashMap'>聊聊并发（四）——深入分析ConcurrentHashMap</a></p>
</li>

<li>
<p><a href='http://coolshell.cn/articles/9606.html'>疫苗：Java HashMap的死循环</a></p>
</li>

<li>
<p><a href='http://www.iteye.com/topic/260515/'>用happen-before规则重新审视DCL</a></p>
</li>

<li>
<p><a href='http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html'>The &#8220;Double-Checked Locking is Broken&#8221; Declaration</a></p>
</li>
</ul>
</div>


            <div class="footer">
              <div class="contact">
                <p>
                  Lin Yong<br />
                  My Douban<br />
                  fantasylinyong@gmail.com
                </p>
              </div>
              <div class="contact">
                <p>
                  <a href="http://github.com/nanchenzi/" target="_blank">github.com/nanchenzi</a><br />
                  <a href="http://www.douban.com/people/kiss2375/" target="_blank">douban.com/people/kiss2375</a><br />
                  <a href="http://instagram.com/kiss2375/" target="_blank">instagram.com/kiss2375</a><br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
